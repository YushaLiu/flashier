---
title: "Analysis of single-cell RNA-seq data using flashier"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Analysis of single-cell RNA-seq data using flashier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The aim of this vignette is show how flashier can be used to analyze
single-cell RNA-seq data. This vignette is modeled after the
[fastTopics vignette on analyzing single-cell data][fasttopics-vignette].

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, comment = "#>",
                      fig.width = 6, fig.height = 6, warning = FALSE,
                      results = "hold", fig.align = "center", dpi = 120)
```

We begin by loading the packages. We also set the seed so the results
can be fully reproduced.

```{r load-pkgs, message=FALSE}
library(Matrix)
library(ebnm)
library(flashier)
library(fastTopics)
library(cowplot)
library(ggplot2)
library(ggrepel)
library(pheatmap)
set.seed(3)
```

Preparing the single-cell data for flashier
-------------------------------------------

The single-cell RNA-seq data are unique molecular identifier (UMI)
counts stored as an $n \times m$ sparse matrix, where $n$ is the
number of cells and $m$ is the number of genes:

```{r load-data}
data("pbmc_facs")
counts <- pbmc_facs$counts
dim(counts)
```

Since the flashier model, like other linear-model-based methods (e.g.,
principal components analysis), was not designed for count data, it is
recommended to first transform the data in a way that makes them more
suitable for flashier. A widely used approach is to divide the counts
by a "size factor", add a "pseudocount", then take the log. We call
this transformation the "shifted logarithm", following
[this paper][ahlmann-eltze-huber-2023], and we refer to the
transformed counts as "shifted log counts".
  
In practice, the shifted log counts are computed as follows: we first
divide the counts by $\alpha s_i$, where $s_i$ is the size factor for
cell $i$, and $\alpha$ is the pseudocount. Done this way, the shifted
log counts maintain sparsity in the data; that is, if the original
count is zero, then the shifted log count is also zero.
  
More formally, the transformed counts $y_{ij}$ obtained from the
original counts $x_{ij}$ are
$$
y_{ij} = \log\bigg(1 + \frac{x_{ij}}{\alpha s_i}\bigg),
$$
in which
$$
s_i =
\frac{\text{total count for cell} \; i}
     {\text{average across all cells}} =
\frac{\sum_{j=1}^m x_{ij}}
     {\frac{1}{n}\sum_{i=1}^n \sum_{j=1}^m x_{ij}}.
$$
In our analysis below, we set the pseudocount, $\alpha$, to 1.

To perform these calculations efficiently on a
sparse matrix, we first define the "log1p_sparse" function,

```{r log1p-sparse}
log1p_sparse <- function (counts) {
  out   <- counts
  out@x <- log1p(counts@x)
  return(out)
}
```

then we compute the shifted log counts:

```{r shifted-log-counts}
a <- 1
n <- nrow(counts)
size_factors       <- rowSums(counts)/(sum(counts)/n)
shifted_log_counts <- log1p_sparse(counts/(a*size_factors))
```

Variance regularization
-----------------------

Before we run flashier, one issue we need to confront is that flashier
may automatically estimate the variances to be too small, which can
especially be an issue for genes with low expression. We can avoid
this issue by setting a sensible lower bound on the variance
estimates.

When running `flashier`, we need to place some regularization on the
variance estimates. Without regularization, it is possible for some
variance estimates to be very small, and thus lead to overfitting. We
use the following rule of thumb: compute the standard deviation of the
transformed data for a Poisson random variable with rate $\mu = 1/n$,
where $n$ is the number of samples. ($\mu = 1/n$ is a lower bound on
the rate for each gene). This standard deviation can be thought of as
a lower bound on the variance we might expect, and it can be used to
prevent the variance estimates from getting too small.

```{r variance-lower-bound}
x  <- rpois(1e7,1/n)
s1 <- sd(log(x + 1))
```

Fit a flashier model
--------------------

Now we can call flash to fit a flashier model to the transformed
data:

```{r flash}
fit <- flash(shifted_log_counts,ebnm_fn = ebnm_point_exponential,
             var_type = 2,greedy_Kmax = 8,S = s1)
```

A few notes about this flash call:

+ `ebnm_fn = ebnm_point_exponential` forces both the L and F
  matrices in flashier to be non-negative, so this call will generate
  a non-negative matrix factorization (NMF) of the (transformed)
  counts matrix. Other types of matrix factorizations can be produced
  with different choices of the "ebnm_fn" argument; this is explained
  in detail in the "introduction to flashier" vignette.

+ `var_ype = 2` means that we estimate column-wise (here, gene-wise)
  variances; that is, we estimate a different variance for each column
  (gene).

+ `greedy_Kmax = 8` forces flashier to fit no more than 8 factors.

Scaling the membership and factor matrices
------------------------------------------

The loading and factor matrix pair are unique up to a scaling. We may
desire to normalize the loading matrix such that for each factor, the
maximum loading value is 1. We should also scale the factor matrix
accordingly.

```{r ldf}
res <- ldf(fit,type = "i")
```
  
These scaled versions are particularly helpful for visualizations.

Looking at membership matrix
----------------------------

For a flashier fit with $K$ factors, each cell $i$ is represented as a
convex combination of these factors. For each cell, we have $K$ factor
membership levels -- they are all stored in the $n \times K$ loading
matrix. These proportions are learned from the data.
  
Here are some examples:

```{r}
rows <- c("GATATATGTCAGTG-1-b_cells",
          "GACAGTACCTGTGA-1-memory_t",
          "TGAAGCACACAGCT-1-b_cells")
round(res$L[rows,],digits = 3)
```
    
We can see that the sample `GATATATGTCAGTG-1-b_cells` primarily shows
membership in factors 1 and 6, with very small levels of membership in
factors 5 and 9. Meanwhile, the sample `GACAGTACCTGTGA-1-memory_t`
primarily shows membership in factors 1 and 5, with very small
membership in factor 14.

Interpreting factors using available cell labels
------------------------------------------------

In the PBMC data, in addition to gene expression data, we have cell
labels. Each cell is assigned to one of five labels (each
corresponding to a cell type): B cells, CD14+ monocytes, CD3+ cells,
natural killer (NK) cells, and T cells. This additional information
can be used to help interpret our factors.

```{r}
summary(pbmc_facs$samples$subpop)
```
    
We can visualize the loadings using a structure plot. A structure plot
is a stacked bar plot in which each factor is represented as a bar of
a different color, and the bar heights are membership levels. This
plot can help visualize the relationship between cell labels and
factor membership levels.
  
For this structure plot, we visualize the scaled loadings from
earlier.

```{r, fig.height=2, fig.width=7.5, results="hide", message=FALSE}
flashier_structure_plot <- function (ldf, grouping) {
  class(ldf) <- c("multinom_topic_model_fit","list")
  return(structure_plot(ldf,grouping = grouping,gap = 20) +
         labs(y = "membership",color = "factor",fill = "factor"))
}
flashier_structure_plot(res,pbmc_facs$samples$subpop)
```
  
We can see that the first factor is somewhat equally present in all cell types. (The first factor is often interpreted as an intercept factor). To focus on the differences between cell types, we can take that factor out of our visualization.

```{r, fig.height=2, fig.width=7.5, results="hide", message=FALSE}
res1 <- res
res1$L[,1] <- 0
res1$F[,1] <- 0
flashier_structure_plot(res1,pbmc_facs$samples$subpop)
```
  
From the structure plot, we can see that NK cells, B cells, CD14+
cells, and T cells have high membership levels in factors 2, 6, 3, and
5, respectively.
  
We can also visualize the loadings with a heatmap. A heatmap
visualizes the matrix of loading values, and a more saturated color
corresponds to a higher value. Again, we use the scaled loadings.

```{r}
loadings_heatmap <- function(fit_L, grouping, sample.names, grouping_col, subjects_subset = NULL){
  if (is.null(subjects_subset) == FALSE){
    anno <- data.frame(subpop = grouping[(subjects_subset)])
    anno_colors <- list(subpop = grouping_col)
  }
  else{
    anno <- data.frame(subpop = grouping)
    anno_colors <- list(subpop = grouping_col)
  }
  if (is.null(colnames(fit_L))){
    colnames(fit_L) <- paste0('k',c(1:ncol(fit_L)))
  }
  if (is.null(rownames(fit_L))){
    rownames(fit_L) <- sample.names
  }
  rownames(anno) <- sample.names
  cols <- colorRampPalette(c("gray96","red"))(50)
  brks <- seq(min(fit_L), max(fit_L),length.out= 50)
  rows <- order(anno$subpop)
  p <- pheatmap(fit_L[rows,], cluster_rows = FALSE, cluster_cols = FALSE,
          show_rownames = FALSE, annotation_row = anno, annotation_names_row = FALSE,
          annotation_colors = anno_colors, angle_col = 45, fontsize = 8, color = cols, breaks = brks, main = "")
  print(p)
}
```

```{r, fig.height=6, fig.width=6, eval=FALSE}
grouping_col <- rainbow(5)
names(grouping_col) <- levels(samples$subpop)
colnames(L.scaled) <- paste0('k',c(1:ncol(L.scaled)))
loadings_heatmap(fit_L = L.scaled, grouping = samples$subpop, sample.names = rownames(L.scaled), grouping_col)
```
  
From the heatmap, we see that almost all samples have membership in
factor 1, supporting the interpretation of the first factor as an
'intercept factor'. We also see that the loadings of factors 2, 4, 5,
and 6 generally correspond with NK cells, CD34+ cells, T cells, and B
cells, respectively.

Factors capture patterns of relative expression
-----------------------------------------------

Each factor is represented as a vector of $m$ expression levels (one
for each gene). All of the factors are stored in an $m \times K$
matrix. The entries of this matrix approximately represent the
log-fold change (LFC) of a given gene in a given factor.
    
For the scaled factor matrix, the entries can be interpreted as the
log-fold-change of a given gene in a given factor if a sample has a
membership level of 1 for that factor.

```{r, eval=FALSE}
dim(fit.nn$F_pm)
```
    
As mentioned previously, the first factor is often interpreted as an intercept factor. It is usually loaded on all of the samples, and its expression levels across genes is relatively 'flat', i.e. there isn't a subset of genes that are more highly-expressed.    
    
Other factors may have (relatively) high levels of expression in only a subset of genes. In addition, genes may be highly expressed in only a subset of factors. For example, genes CD79A and CD79B are important to B cells, and thus we would expect them to have higher expression in factor 6.  

```{r, eval=FALSE}
genes <- pbmc_facs$genes
rbind(fit.nn$F_pm[genes$symbol == "CD79B",],
      fit.nn$F_pm[genes$symbol == "CD79A",])
```

Annotating topics by differentially expressed genes
--------------------
When interpreting the factors, we can look at the top driving genes for each factor. For example, for a given factor, we can find the genes with the top 10 highest expression levels.  

```{r, eval=FALSE}
get_top_genes <- function(fit, threshhold = 2, rowname_F){
  FF <- fit$F_pm
  LL <- fit$L_pm
  Fnorm <- t(t(FF)*apply(LL,2,max))
  rownames(Fnorm) <- rowname_F
  top_genes_list <- list()
  for (k in 1:ncol(Fnorm)){
    cur.genes <- rownames(Fnorm)[Fnorm[, k] > log(threshhold)]
    F.tmp <- Fnorm[cur.genes,]
    cur.genes <- rownames(F.tmp)[order(F.tmp[, k], decreasing = TRUE)] #re-order the genes
    lfc <- round(Fnorm[cur.genes, k], 3)
    dat <- data.frame(gene=cur.genes, lfc=lfc)
    rownames(dat) <- 1:nrow(dat)
    top_genes_list[[k]] <- dat # add the dataframe to the list of top driving genes
  }
  names(top_genes_list) <- paste0('Factor', c(1:ncol(Fnorm)))
  return(top_genes_list)
}
```
  
These are the top genes for factor 6:
```{r, eval=FALSE}
top_genes_list <- get_top_genes(fit.nn, rowname_F = genes$symbol)
print(top_genes_list[[6]][1:10,])
```
    
We can also visualize the top genes for a given factor with a volcano plot. A volcano plot is a type of scatter plot. On the x-axis, we plot the log-fold-change in expression levels for a given gene in a given factor. On the y-axis, we plot the mean expression level of the given gene across all cells in the (transformed) data matrix.

```{r, eval=FALSE}
volcano_plot <- function(gene, lfc, z, lfsr, k){
pdat <- data.frame(gene = gene, 
                   lfc  = lfc[,k], 
                   z    = abs(z), 
                   lfsr = lfsr[,k],
                   stringsAsFactors = FALSE)
pdat <- transform(pdat,lfsr = cut(lfsr, c(-1,0.001,0.01,0.05,Inf)))
rows  <- with(pdat, which(!(abs(lfc) > quantile(abs(lfc),0.999))))
pdat[rows, "gene"] <- ""
p <- ggplot(pdat, aes(x = lfc, y = z, color = lfsr, label = gene)) +
  geom_point() + 
  geom_text_repel(color = "black", size = 2.3, segment.color = "black",
                  segment.size = 0.25, min.segment.length = 0,
                  max.overlaps = Inf, na.rm = TRUE) +
  scale_color_manual(values = c("coral","orange","gold","deepskyblue")) +
  labs(x = "log-fold change", y = "mean expression level") + 
  theme_cowplot(font_size = 10)
print(p)
}
```
  
This is the volcano plot for factor 6:

```{r, eval=FALSE}
z <- (1/nrow(shifted_log_counts))*colSums(shifted_log_counts)
volcano_plot(genes$symbol, fit.nn$F_pm, as.matrix(z, ncol = 1), fit.nn$F_lfsr, 6)
```

We see that the top 10 most highly-expressed genes for factor 6 are identified in the volcano plot.

```{r session-info}
sessionInfo()
```

[zheng-2017]: https://doi.org/10.1038/ncomms14049
[fasttopics-vignette]: https://stephenslab.github.io/fastTopics/articles/single_cell_rnaseq_basic.html
[ahlmann-eltze-huber-2023]: https://doi.org/10.1038/s41592-023-01814-1
