% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash.R
\name{flash}
\alias{flash}
\title{Empirical Bayes matrix factorization}
\usage{
flash(
  data,
  S = NULL,
  ebnm.fn = ebnm::ebnm_point_normal,
  var.type = 0L,
  greedy.Kmax = 50L,
  backfit = FALSE,
  nullcheck = TRUE,
  verbose.lvl = 1L
)
}
\arguments{
\item{data}{The observations. Usually a matrix, but can also be a sparse
matrix of class \code{Matrix} or a low-rank matrix
representation as returned by, for example, \code{\link{svd}},
\code{\link[irlba]{irlba}}, \code{\link[rsvd]{rsvd}}, or
\code{\link[softImpute]{softImpute}} (in general, any list object that
includes fields \code{u}, \code{d}, and \code{v} will be interpreted
as a low-rank matrix representation).}

\item{S}{The standard errors. Can be \code{NULL} (in which case all residual
variance will be estimated) or a matrix, vector, or scalar. \code{S}
should be a scalar if standard errors are the same for all observations,
and a vector if standard errors either vary across columns but are
constant within any given row, or vary across rows and are constant within
any given column (function \code{flash} will use the length of the vector
to determine whether standard errors correspond to rows or columns; if the
data matrix is square, then the sense must be specified using parameter
\code{S.dim} in function \code{\link{flash.init}}).}

\item{ebnm.fn}{The function or functions used to solve the empirical Bayes
  normal means (EBNM) subproblems. Most importantly, these functions specify
  the families of distributions \eqn{G_\ell} and \eqn{G_f} from which the
  priors on loadings and factors \eqn{g_\ell} and \eqn{g_f} are
  to be estimated. If the same function is to be used for both loadings
  \eqn{L} and factors \eqn{F}, then \code{ebnm.fn} can be a single function;
  if different functions are to be used, then \code{ebnm.fn} should be a
  list of length two, with the first list element giving the function for
  loadings and the second element giving the function for factors (see
  \strong{Examples} below).
  If different functions are to be used for different values of \eqn{k},
  then factors must be added successively using multiple calls to either
  \code{\link{flash.add.greedy}} or \code{\link{flash.init.factors}}.

  Any EBNM function provided by package \code{\link[ebnm]{ebnm}} can be
  used as input. Non-default arguments to parameters can be supplied using
  the helper function \code{\link{as.ebnm.fn}}. Custom EBNM functions can
  also be used: for details, see \code{\link{as.ebnm.fn}}.}

\item{var.type}{Describes the structure of the estimated residual variance.
  Can be \code{NULL}, \code{0}, \code{1}, \code{2}, or \code{c(1, 2)}. If
  \code{NULL}, then \code{S} accounts for all residual variance. If
  \code{var.type = 0}, then the estimated residual variance (which is added
  to any variance given by \code{S}) is assumed to be constant
  across all observations. Setting \code{var.type = 1} estimates a single
  variance parameter for each row; \code{var.type = 2} estimates one
  parameter for each column; and \code{var.type = c(1, 2)} optimizes over
  all rank-one matrices.

  Note that if any portion of the residual variance is to be estimated, then
  it is usually faster to set \code{S = NULL} and let \code{flash}
  estimate all of the residual variance. Further, \code{var.type = c(1, 2)}
  is much slower than all other options, so it should be used with care.}

\item{greedy.Kmax}{The maximum number of factors to be added. This will not
necessarily be the total number of factors added by \code{flash}, since
factors are only added as long as they increase the variational lower
bound on the log likelihood for the model.}

\item{backfit}{A "greedy" fit is performed by adding up to
\code{greedy.Kmax} factors, optimizing each newly added factor in one go
without returning to optimize previously added factors. When
\code{backfit = TRUE}, \code{flash} will additionally perform a final
"backfit" where all factors are cyclically updated until convergence.
The backfitting procedure typically takes much longer than the greedy
algorithm, but it also usually improves the final fit to a significant
degree.}

\item{nullcheck}{If \code{nullcheck = TRUE}, then \code{flash} will check
that each factor in the final flash object improves the overall fit. Any
factor that fails the check will be removed.}

\item{verbose.lvl}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
Set to \code{-1} to output a single tab-delimited table of values.}
}
\value{
A \code{flash} object. Contains elements:
  \describe{
    \item{\code{n.factors}}{The total number of factors \eqn{K} in the fitted
      model.}
    \item{\code{pve}}{The proportion of variance explained by each factor.
      Since the factors are not required to be orthogonal, this should be
      interpreted loosely: for example, the total proportion of variance
      explained could be larger than 1.}
    \item{\code{elbo}}{The variational lower bound achieved by the
      fitted model.}
    \item{\code{residuals.sd}}{Estimated residual standard deviations (these
      include any variance component given as an argument to \code{S}).}
    \item{\code{loadings.pm, loadings.psd, loadings.lfsr}}{Posterior means,
      standard deviations, and local false sign rates for loadings \eqn{L}.}
    \item{\code{factors.pm, factors.psd, factors.lfsr}}{Posterior means,
      standard deviations, and local false sign rates for factors \eqn{F}.}
    \item{\code{loadings.priors}}{The fitted priors on loadings
      \eqn{\hat{g}_\ell^{(k)}}.}
    \item{\code{factors.priors}}{The fitted priors on factors
      \eqn{\hat{g}_f^{(k)}}.}
    \item{\code{sampler}}{A function that takes a single argument
      \code{nsamp} and returns \code{nsamp} samples from the posterior
      distribution of the (non-normalized) loadings.}
    \item{\code{flash.fit}}{A \code{flash.fit} object. Used by
      \code{flash} when fitting is not performed all at once, but
      incrementally via calls to various \code{flash.xxx} functions.}
  }
  Additionally, two methods are available. \code{\link{fitted.flash}}
    returns the "fitted values" \eqn{E(LF') = E(L) E(F)'}.
    \code{\link{ldf.flash}} returns an \eqn{LDF} decomposition (see
    \strong{Details} above), with columns of \eqn{L} and \eqn{F} scaled
    as specified by the user.
}
\description{
Fits an empirical Bayes matrix factorization (see \strong{Details} for a
  description of the model). The resulting fit is referred to as a "flash"
  object (short for Factors and Loadings using Adaptive SHrinkage). Two
  interfaces are provided. The \code{flash} function provides a simple
  interface that allows a flash object to be fit in a single pass, while
  \code{flash.xxx} functions are pipeable functions that allow for more
  complex flash objects to be fit incrementally (available functions are
  listed below under \strong{See Also}). See the vignettes and
  \strong{Examples} for usage.
}
\details{
If \eqn{Y} is an \eqn{n \times p} data matrix, then the rank-one
  empirical Bayes matrix factorization model is:
\deqn{Y = \ell f' + E,} where \eqn{\ell} is an
  \eqn{n}-vector of \strong{loadings}, \eqn{f} is a
  \eqn{p}-vector of \strong{factors}, and \eqn{E} is an
  \eqn{n \times p} matrix of \strong{residuals} (or "errors").
  Additionally:
\deqn{e_{ij} \sim N(0, s_{ij}^2): i = 1, ..., n; j = 1, ..., p}
\deqn{\ell \sim g_\ell \in G_\ell}
\deqn{f \sim g_f \in G_f.}
The residual variance parameters \eqn{s_{ij}^2} are constrained to have
  a simple structure and are fit via maximum likelihood. (For example, one
  might assume that all standard errors are identical: \eqn{s_{ij}^2 = s^2}
  for some \eqn{s^2} and for all \eqn{i}, \eqn{j}).
The functions \eqn{g_\ell} and \eqn{g_f} are assumed to belong to
  some families of priors \eqn{G_\ell} and \eqn{G_f} that are
  specified in advance, and are estimated via variational approximation.

The general rank-\eqn{K} empirical Bayes matrix factorization model is:
  \deqn{Y = LF' + E} or
  \deqn{y_{ij} = \sum_k \ell_{ik} f_{jk} + e_{ij}: i = 1, ..., n; j = 1, ..., p,}
  where \eqn{L} is now a matrix of loadings and \eqn{F} is a matrix of
  factors.

Separate priors \eqn{g_\ell^{(k)}} and \eqn{g_f^{(k)}} are estimated via
  empirical Bayes, and different prior families may be used for different
  values of \eqn{k}. In general, then:
  \deqn{e_{ij} \sim N(0, s_{ij}^2): i = 1, ..., n; j = 1, ..., p}
  \deqn{\ell_{ik} \sim g_\ell^{(k)} \in G_\ell^{(k)}: i = 1, ..., n; k = 1, ..., K}
  \deqn{f_{ik} \sim g_f^{(k)} \in G_f^{(k)}: j = 1, ..., p; k = 1, ..., K.}

Typically, \eqn{G_\ell^{(k)}} and \eqn{G_f^{(k)}} will be closed under
  scaling, in which case \eqn{\ell_k} and \eqn{f_k} are only identifiable
  up to a \strong{scaling factor} \eqn{d_k}. In other words, we can write:
  \deqn{Y = LDF' + E,}
  where \eqn{D} is a diagonal matrix with diagonal entries \eqn{d_1, ..., d_K}.
  The model can then be made identifiable by constraining the scale of
  \eqn{\ell_k} and \eqn{f_k} for \eqn{k = 1, ..., K}.
}
\examples{
data(gtex)

# Fit up to 10 factors and backfit.
fl <- flash(gtex, greedy.Kmax = 10L, backfit = TRUE)

# This is equivalent to the series of calls:
fl <- flash.init(gtex) \%>\%
  flash.add.greedy(Kmax = 10L) \%>\%
  flash.backfit() \%>\%
  flash.nullcheck()

# Fit a unimodal distribution with mean zero to each set of loadings
#   and a scale mixture of normals with mean zero to each factor.
fl <- flash(gtex,
            ebnm.fn = c(ebnm::ebnm_unimodal,
                        ebnm::ebnm_normal_scale_mixture),
            greedy.Kmax = 5)

# Fit point-laplace priors using a non-default optimization method.
fl <- flash(gtex,
            ebnm.fn = as.ebnm.fn(prior_family = "point_laplace",
                                 optmethod = "trust"),
            greedy.Kmax = 5)

# Fit a "Kronecker" (rank-one) variance structure (this can be slow).
fl <- flash(gtex, var.type = c(1, 2), greedy.Kmax = 5L)

}
\seealso{
\code{\link{fitted.flash}}, \code{\link{ldf.flash}},
  \code{\link{flash.init}}, \code{\link{flash.add.greedy}},
  \code{\link{flash.backfit}}, and \code{\link{flash.nullcheck}}. For more
  advanced functionality, see \code{\link{flash.init.factors}},
  \code{\link{flash.fix.loadings}}, \code{\link{flash.set.factors.to.zero}},
  \code{\link{flash.remove.factors}}, and \code{\link{flash.set.verbose}}.
}
