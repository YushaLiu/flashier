% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_fit_object.R
\name{flash.fit}
\alias{flash.fit}
\title{Extract a flash.fit object}
\usage{
flash.fit(flash)
}
\arguments{
\item{flash}{A \code{flash} object.}
}
\value{
A \code{flash.fit} object. A non-exhaustive list of the fields it
  can contain includes:
  \describe{
    \item{\code{Y}}{The data matrix, with missing data (NAs) replaced by
      zeros.}
    \item{\code{Z}}{A matrix of 0s and 1s indicating whether data is missing
      (0) or present (1). If there is no missing data, then a scalar might
      be stored rather than a full matrix of 1s.}
    \item{\code{n.nonmissing}}{The number of nonmissing entries (total, by
      row, or by column, depending on the variance type).}
    \item{\code{Y2}}{The data sum of squares (total, by row, or by column).}
    \item{\code{R2}}{The sum of expected squared residuals (total, by row,
      or by column).}
    \item{\code{est.tau.dim}}{Describes the structure of the estimated
      portion of the residual variance. Identical to parameter
      \code{var.type} in function \code{\link{flash}}.}
    \item{\code{est.tau}}{Equal to \eqn{1 / \sigma^2}, where \eqn{\sigma^2}
      is the estimated portion of the residual variance (total, by row, or
      by column).}
    \item{\code{given.tau}}{Equal to \eqn{1 / s^2}, where \eqn{s^2} is the
      fixed portion of the residual variance.}
    \item{\code{given.tau.dim}}{Describes the structure of the fixed
      portion of the residual variance. Analogous to \code{est.tau.dim}.}
    \item{\code{tau}}{The overall precision \eqn{1 / (\sigma^2 + s^2)}.}
    \item{\code{obj}}{The ELBO.}
    \item{\code{fix.dim, fix.idx}}{Lists. If there are any fixed elements
      in loadings \eqn{\ell_k} or factor \eqn{f_k}, then the mode --- i.e.,
      whether loadings (1) or factors (2) are fixed --- is given by
      \code{fix.dim[[k]]} and the indices \eqn{i} of the fixed elements
      \eqn{\ell_{ik}} or \eqn{f_{ik}} are given by \code{fix.idx[[k]]}.}
    \item{\code{use.fixed.to.est.g}}{Should fixed elements be used or
      ignored when solving the EBNM subproblem in order to estimate
      the prior \eqn{\hat{g}}?}
    \item{\code{verbose.lvl, verbose.fns, verbose.colnames,
      verbose.colwidths}}{Settings for verbose output. See function
      \code{\link{flash.set.verbose}}.}
    \item{\code{EF, EF2}}{Lists of matrices. \code{EF[[1]]} and
      \code{EF2[[1]]} are \eqn{n \times k} matrices of, respectively,
      first and second posterior moments for the loadings matrix \eqn{L},
      and \code{EF[[2]]} and \code{EF2[[2]]} are \eqn{p \times k} matrices
      of first and second posterior moments for the factors matrix \eqn{F}.}
    \item{\code{KL}}{A list of vectors giving the KL-divergence portion of
      the ELBO for loadings (\code{KL[[1]]}) and factors (\code{KL[[2]]}).}
    \item{\code{g}}{A list of lists giving estimated priors \eqn{\hat{g}}.
      \code{g[[k]]} gives estimated priors for \eqn{\ell_k}
      (\code{g[[k]][[1]]}) and \eqn{f_k} (\code{g[[k]][[2]]}).}
    \item{\code{ebnm.fn}}{A list of lists containing the functions used
      to solve the EBNM subproblems. The structure of the list is similar
      to the structure of field \code{g} described above.}
    \item{\code{is.valid}}{A boolean vector of length \eqn{K} that indicates
      whether each factor represents a valid contribution to the ELBO. For
      this to be true, it cannot simply be initialized, but must be updated
      at least once using the greedy or backfit algorithm.}
    \item{\code{is.zero}}{A boolean vector of length \eqn{K} that indicates
      whether each factor is identically zero.}
    \item{\code{warmstart.greedy}}{Should warmstarts be used when fitting
      new factors using the greedy algorithm? (See function
      \code{\link{flash.add.greedy}}.)}
    \item{\code{warmstart.backfit}}{Should warmstarts be used when refining
      a flash fit using the backfit algorithm? (See function
      \code{\link{flash.backfit}}.)}
    \item{\code{maxiter.reached}}{This flag is set when a backfit terminates
      because the maximum number of iterations has been reached. If a
      backfit goes to convergence, then the flag is cleared.}
  }
  The following methods are available for \code{flash.fit} objects:
  \describe{
    \item{\code{\link{fitted.flash.fit}}}{Returns the "fitted values"
      \eqn{E(LF') = E(L) E(F)'}.}
    \item{\code{\link{residuals.flash.fit}}}{Returns the expected residuals
      \eqn{Y - E(LF') = Y - E(L) E(F)'}.}
    \item{\code{\link{ldf.flash.fit}}}{Returns an \eqn{LDF} decomposition,
      with columns of \eqn{L} and \eqn{F} scaled as specified by the user.}
  }
}
\description{
Extracts a \code{flash.fit} object from a \code{\link{flash}} object.
}
\details{
\code{flash.fit} objects are the "internal" objects that \code{flash}
  functions manipulate to fit an EBMF model. Whereas \code{flash} objects
  (the end results of the fitting process) include user-friendly fields and
  methods, \code{flash.fit} objects were not designed for public
  consumption and can be very unwieldy. Nonetheless, some advanced
  \code{flash} functionality requires a working knowledge of the structure
  of \code{flash.fit} objects. In particular, initialization, convergence,
  and "verbose" display functions all take one or more \code{flash.fit}
  objects as input (see parameter \code{init.fn} in function
  \code{\link{flash.add.greedy}}; parameter \code{conv.crit.fn} in
  \code{\link{flash.add.greedy}} and \code{\link{flash.backfit}};
  and parameter \code{fns} in \code{\link{flash.set.verbose}}).
  For users who would like to write custom functions, the description of the
  \code{flash.fit} object given below may prove useful.
}
