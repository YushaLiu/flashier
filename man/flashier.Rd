% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flashier.R
\name{flashier}
\alias{flashier}
\title{Fit an empirical Bayes matrix/tensor factorization}
\usage{
flashier(data = NULL, S = NULL, var.type = 0,
  prior.type = point.normal(), flash.init = NULL, greedy.Kmax = 30,
  backfit = c("none", "final", "alternating", "only"),
  fixed.factors = NULL, verbose.lvl = 1, ...)
}
\arguments{
\item{data}{The observations. Can be a matrix, sparse matrix of class
\code{Matrix}, three-dimensional array, or \code{flash.data} object
obtained from \code{set.flash.data}. Can be \code{NULL} if
\code{flash.init} is used.}

\item{S}{The standard errors. Can be a matrix, scalar (if standard errors
are the same for all observations), or vector (if, for example, \code{S}
only varies across columns and is constant within any given row). If
\code{NULL}, all residual variance will be estimated.}

\item{var.type}{Describes the structure of the estimated residual variance.
Can be \code{NULL}, \code{0}, or a vector. If \code{NULL}, then
\code{S} accounts for all residual variance. Otherwise, a rank-one
variance structure will be estimated (and added to any variance specified
by \code{S}). \code{var.type} then gives the modes along which the
residual variance is permitted to vary. For example, \code{var.type = 1}
estimates row-specific residual variances, while \code{var.type = c(1, 2)}
optimizes over all rank-one matrices. If \code{var.type = 0}, then the
residual variance is assumed to be constant across all observations.}

\item{prior.type}{Indicates the class of distributions that the priors are
  assumed to belong to. Can be a list of length 1 or length \eqn{N}, where
  \eqn{N} is the number of modes (\eqn{N = 2} for matrices; \eqn{N = 3} for
  tensors). Each list element must be a prior type created by one of the
  convenience functions \code{\link{normal}}, \code{\link{point.normal}},
  \code{\link{point.laplace}}, \code{\link{nonzero.mode}},
  \code{\link{normal.mix}}, \code{\link{uniform.mix}},
  \code{\link{nonnegative}}, or \code{\link{nonpositive}}, or a custom
  prior type of a similar form (see \code{\link{normal}} for details).
  For example, the default \code{prior.type = point.normal()} fits a
  (different) point-normal prior for each factor and each mode, while
  \code{prior.type = c(nonnegative(), normal.mix())} fits a mixture of
  uniforms with nonnegative support to each set of row loadings and a
  mixture of normals to each set of column loadings.

  \code{prior.type} can also be a list of lists, in which case the first
  list specifies the class(es) for the first factor, the second specifies
  the class(es) for the second factor, and so on. The last list element is
  then re-used as often as necessary.}

\item{flash.init}{An initial \code{flash} or \code{flash.fit} object.}

\item{greedy.Kmax}{The maximum number of factors to be added. Fixed factors
are not counted.}

\item{backfit}{Whether and how to backfit. If \code{"final"}, then a single
backfit is performed after as many factors as possible have been added.
If \code{"alternating"}, a backfit will be performed after each
factor is added. Set \code{backfit = "only"} to backfit \code{flash.init}
without adding additional factors.}

\item{fixed.factors}{Adds factors with fixed loadings. Options
include mean factors (where all row or column loadings are fixed at 1),
factors with known sparsity patterns, and factors with arbitrarily fixed
elements. See \code{\link{ones.factor}}, \code{\link{sparse.factors}},
and \code{\link{fixed.factors}} for usage. Multiple types of fixed factors
can be added by concatenating via \code{c()}. For example,
\code{fixed.factors = c(ones.factor(n = 1), sparse.factors(n = 1,
nz.idx = 1:10)} will add one mean factor and one sparse factor.}

\item{verbose.lvl}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
Set to \code{-1} to output a single tab-delimited table of values.}

\item{...}{Additional parameters to be passed to
\code{\link{flash.workhorse}}. Not for the faint of heart.}
}
\value{
A \code{flash} object. Contains elements:
  \describe{
    \item{\code{n.factors}}{The total number of factors in the fitted
      model.}
    \item{\code{elbo}}{The variational lower bound achieved by the
      fitted model.}
    \item{\code{pve}}{The proportion of variance explained by each factor.}
    \item{\code{loadings, factor.wts}}{Posterior means for loadings. Since
      the model is not identifiable,
      each column of loadings is \eqn{L2}-normalized. The
      normalization constant is given by \code{factor.wts}. Thus, for
      matrices, fitted values can be calculated as \code{f$loadings[[1]]
      \%*\% diag(f$factor.wts) \%*\% t(f$loadings[[2]])} (or, more simply,
      as \code{fitted(f)}).}
    \item{\code{loading.SDs}}{Posterior standard deviations for loadings.}
    \item{\code{loading.lfsrs}}{Local false sign rates for loadings.}
    \item{\code{residual.SE}}{Estimated residual standard errors (this
      includes any variance component given as an argument to \code{S}).}
    \item{\code{sampler}}{A function that takes a single argument
      \code{nsamp} and returns \code{nsamp} samples from the posterior
      distribution of the (non-normalized) loadings.}
    \item{\code{fit}}{A \code{flash.fit} object. Used by \code{flashier}
      when fitting is not performed all at once, but incrementally via
      repeated calls to \code{flashier} (with the intermediate \code{flash}
      or \code{flash.fit} objects given as arguments to \code{flash.init}).}
  }
}
\description{
TODO: Describe model. Add reference.
}
