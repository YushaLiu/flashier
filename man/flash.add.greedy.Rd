% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_add_greedy.R
\name{flash.add.greedy}
\alias{flash.add.greedy}
\title{Greedily add factors to a flash object}
\usage{
flash.add.greedy(
  flash,
  Kmax = 1,
  ebnm.fn = ebnm::ebnm_point_normal,
  init.fn = init.fn.default,
  extrapolate = FALSE,
  conv.crit.fn = calc.obj.diff,
  tol = set.default.tol(flash),
  maxiter = 500,
  verbose.lvl = get.verbose.lvl(flash)
)
}
\arguments{
\item{flash}{A \code{flash} or \code{flash.fit} object to which factors are
to be added.}

\item{Kmax}{The maximum number of factors to be added. This will not
necessarily be the total number of factors added by
\code{flash.add.greedy}, since factors are only added as long as they
increase the variational lower bound on the log likelihood for the model.}

\item{ebnm.fn}{The function or functions used to solve the empirical Bayes
  normal means (EBNM) subproblems. Most importantly, these functions specify
  the families of distributions \eqn{G_\ell} and \eqn{G_f} from which the
  priors on loadings and factors \eqn{g_\ell} and \eqn{g_f} are
  to be estimated. If the same function is to be used for both loadings
  \eqn{L} and factors \eqn{F}, then \code{ebnm.fn} can be a single function;
  if different functions are to be used, then \code{ebnm.fn} should be a
  list of length two, with the first list element giving the function for
  loadings and the second element giving the function for factors (see
  \strong{Examples} below).
  If different functions are to be used for different values of \eqn{k},
  then factors must be added successively using multiple calls to either
  \code{\link{flash.add.greedy}} or \code{\link{flash.init.factors}}.

  Any EBNM function provided by package \code{\link[ebnm]{ebnm}} can be
  used as input. Non-default arguments to parameters can be supplied using
  the helper function \code{\link{as.ebnm.fn}}. Custom EBNM functions can
  also be used: for details, see \code{\link{as.ebnm.fn}}.}

\item{init.fn}{The function used to initialize factors. Functions
\code{\link{init.fn.default}}, \code{\link{init.fn.softImpute}}, and
\code{\link{init.fn.irlba}} have been supplied, but custom initialization
functions may also be used. In particular, it is important to use an
appropriate initialization function when loadings must be constrained in
some fashion (otherwise, the greedy algorithm can stop adding factors
prematurely). Custom initialization functions should accept a single parameter
\code{flash} (the name of the parameter is unimportant) and should output
a list consisting of two vectors, which will be used as initial values for
the new loadings \eqn{\ell_k} and the new factor \eqn{f_k}. Typically,
a custom initialization function will extract the matrix of residuals from
\code{flash} using the method \code{fitted(flash)} and then return a
(possibly constrained) rank-one approximation to the matrix of residuals.
See \strong{Examples} below.}

\item{extrapolate}{Whether to use an extrapolation technique
inspired by Ang and Gillis (2019) to accelerate the fitting of greedy
factors. Control parameters are handled via global options and
can be set by calling
\code{options("extrapolate.control") <- control.param}.}

\item{conv.crit.fn}{The function used to determine whether convergence has
occurred. TODO: details.}

\item{tol}{The convergence tolerance.}

\item{maxiter}{The maximum number of iterations when optimizing a greedily
added factor.}

\item{verbose.lvl}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
Set to \code{-1} to output a single tab-delimited table of values.}
}
\description{
Adds factors to a flash object in a "greedy" manner. Up to \code{Kmax}
  factors are added one at a time. At each step, \code{flash.add.greedy}
  attempts to find an optimal additional (rank-one) factor given all
  previously added factors. The additional factor is retained if it
  increases the ELBO; otherwise, fitting terminates.
}
\examples{
# Increase the maximum number of iterations in the default initialization
#   method.
fl <- flash.init(gtex) \%>\%
  flash.add.greedy(init.fn = function(f) init.fn.default(f, maxiter = 500))

# Fit a semi-nonnegative matrix factorization.
snmf.fl <- flash.init(gtex) \%>\%
  flash.add.greedy(
    ebnm.fn = c(ebnm::ebnm_unimodal_nonnegative, ebnm::ebnm_point_normal),
    init.fn = function(f) init.fn.default(f, dim.signs = c(1, 0))
  )

# Use a custom initialization function that wraps function nnmf from
#   package NNLM.
nnmf.init.fn <- function(flash) {
  nnmf.res <- NNLM::nnmf(fitted(flash), verbose = FALSE)
  return(list(as.vector(nnmf.res$W), as.vector(nnmf.res$H)))
}
fl.nnmf <- flash.init(gtex) \%>\%
  flash.add.greedy(ebnm.fn = ebnm::ebnm_unimodal_nonnegative,
                   init.fn = nnmf.init.fn)

}
\seealso{
\code{\link{init.fn.default}}, \code{\link{init.fn.softImpute}},
  \code{\link{init.fn.irlba}}
}
