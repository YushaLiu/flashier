% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_add_greedy.R
\name{flash.add.greedy}
\alias{flash.add.greedy}
\title{Greedily add factors to a flash object}
\usage{
flash.add.greedy(
  flash,
  Kmax = 1,
  ebnm.fn = ebnm_point_normal,
  init.fn = NULL,
  extrapolate = FALSE,
  warmstart = FALSE,
  maxiter = 500,
  tol = NULL,
  verbose = NULL
)
}
\arguments{
\item{flash}{A \code{flash} or \code{flash.fit} object to which factors are
to be added.}

\item{Kmax}{The maximum number of factors to be added. This will not
necessarily be the total number of factors added by
\code{flash.add.greedy}, since factors are only added as long as they
increase the ELBO.}

\item{ebnm.fn}{The function or functions used to solve the empirical Bayes
  normal means (EBNM) subproblems. Most importantly, these functions specify
  the families of distributions \eqn{G_\ell^{(k)}} and \eqn{G_f^{(k)}} to which the
  priors on loadings and factors \eqn{g_\ell^{(k)}} and \eqn{g_f^{(k)}} are
  assumed to belong. If the same function is to be used for both loadings
  \eqn{L} and factors \eqn{F}, then \code{ebnm.fn} can be a single function.
  If one function is to be used for loadings and a second for factors,
  then \code{ebnm.fn} should be a list of length two, with the first
  element giving the function for loadings and the second the function
  for factors. If different functions are to be used for different values of
  \eqn{k}, then factor/loadings pairs must be added successively using
  multiple calls to either \code{\link{flash.add.greedy}} or
  \code{\link{flash.init.factors}}.

  Any EBNM function provided by package \code{\link[ebnm]{ebnm}} can be
  used as input. Non-default arguments to parameters can be supplied using
  the helper function \code{\link{as.ebnm.fn}}. Custom EBNM functions can
  also be used: for details, see \code{\link{as.ebnm.fn}}.}

\item{init.fn}{The function used to initialize factor/loadings pairs. Functions
\code{\link{init.fn.default}}, \code{\link{init.fn.softImpute}}, and
\code{\link{init.fn.irlba}} have been supplied
(\code{\link{init.fn.softImpute}} can yield better results than the
default initialization function when there is missing data). Custom
initialization functions may also be used. If \code{init.fn = NULL} then
\code{init.fn.default} will be used; \code{flash.add.greedy} will
attempt to set argument \code{dim.signs} appropriately via test calls to
the EBNM function(s) specified by \code{ebnm.fn}. If factors or loadings
are constrained in some other fashion (e.g., bounded support), then the
initialization function should be modified to account for the constraints
--- otherwise, the greedy algorithm can stop adding factor/loadings pairs
too early. Custom initialization functions should accept a single
parameter referring to a \code{\link{flash.fit}} object and should output
a list consisting of two vectors, which will be used as initial values for
the new loadings \eqn{\ell_k} and the new factor \eqn{f_k}. Typically,
a custom initialization function will extract the matrix of residuals from
the \code{flash.fit} object using the method \code{residuals.flash.fit} and
then return a (possibly constrained) rank-one approximation to the matrix
of residuals. See \strong{Examples} below.}

\item{extrapolate}{Whether to use an extrapolation technique
inspired by Ang and Gillis (2019) to accelerate the fitting process.
Control parameters are handled via global options and can be set by
calling \code{options("extrapolate.control") <- control.param}.}

\item{warmstart}{Whether to use "warmstarts" when solving the EBNM
subproblems by initializing solutions at the previous value of the fitted
prior \eqn{\hat{g}}. An important side effect of warmstarts for
\code{ashr}-like prior families is to fix the grid at its initial setting.
Fixing the grid can lead to poor fits if there
are large changes in the scale of the estimated prior over the
course of the fitting process. However, allowing the grid to
vary can occasionally result in decreases in ELBO.}

\item{maxiter}{The maximum number of iterations when optimizing a greedily
added factor.}

\item{verbose}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
It is also possible to output a single tab-delimited table of values
using function \code{\link{flash_set_verbose}} with \code{verbose = -1}.}
}
\value{
A \code{\link{flash}} object.
}
\description{
Adds factor/loadings pairs to a flash object in a "greedy" manner. Up to
  \code{Kmax} pairs are added one at a time. At each step, \code{flash.add.greedy}
  attempts to find an optimal additional (rank-one) factor given all
  previously added factors. The additional factor is retained if it
  increases the variational lower bound (ELBO); otherwise, fitting terminates.
}
\examples{
# Increase the maximum number of iterations in the default initialization
#   method.
fl <- flash.init(gtex) \%>\%
  flash.add.greedy(init.fn = function(f) init.fn.default(f, maxiter = 500))

# Use a custom initialization function that wraps function nmf from
#   package RcppML.
nmf.init.fn <- function(f) {
  nmf.res <- RcppML::nmf(resid(f), k = 1, verbose = FALSE)
  return(list(as.vector(nmf.res$w), as.vector(nmf.res$h)))
}
fl.nmf <- flash.init(gtex) \%>\%
  flash.add.greedy(ebnm.fn = ebnm_unimodal_nonnegative,
                   init.fn = nmf.init.fn)

}
\seealso{
\code{\link{init.fn.default}}, \code{\link{init.fn.softImpute}},
  \code{\link{init.fn.irlba}}
}
