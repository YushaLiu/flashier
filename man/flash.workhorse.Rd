% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_workhorse.R
\name{flash.workhorse}
\alias{flash.workhorse}
\title{A horse that works for flashier}
\usage{
flash.workhorse(data, flash.init = NULL, var.type = 0, prior.sign = NULL,
  ebnm.fn = flashr:::ebnm_pn, ebnm.param = list(), greedy.Kmax = 100,
  backfit.order = c("sequential", "random", "montaigne", "parallel"),
  warmstart.backfits = TRUE, backfit.after = NULL, backfit.every = NULL,
  final.backfit = FALSE, nullchk.after = NULL, nullchk.every = NULL,
  final.nullchk = TRUE, conv.crit.fn = calc.obj.diff, verbose.lvl = 1,
  verbose.fns = NULL, verbose.colnames = NULL, verbose.colwidths = NULL,
  output.lvl = 2, EF.init = NULL, fix.dim = NULL, fix.idx = NULL,
  fix.vals = NULL, use.fixed.to.est.g = FALSE,
  nullchk.fixed.factors = FALSE, init.fn = NULL, init.maxiter = 100,
  init.tol = 0.01, greedy.maxiter = 500, greedy.tol = NULL,
  backfit.maxiter = 100, backfit.tol = greedy.tol,
  inner.backfit.maxiter = backfit.maxiter, inner.backfit.tol = backfit.tol,
  seed = 666, use.R = FALSE)
}
\arguments{
\item{data}{The observations. Can be a matrix, sparse matrix of class
\code{Matrix}, or three-dimensional array.}

\item{flash.init}{An initial \code{flash} or \code{flash.fit} object.}

\item{var.type}{Describes the structure of the estimated residual variance.
Can be \code{NULL}, \code{0}, or a vector. If \code{NULL}, then
\code{S} accounts for all residual variance. Otherwise, a rank-one
variance structure will be estimated (and added to any variance specified
by \code{S}). \code{var.type} then gives the dimensions
along which the residual variance is permitted to vary. For example,
\code{var.type = 1} estimates row-specific residual variances, while
\code{var.type = c(1, 2)} estimates an arbitrary rank-one matrix. If
\code{var.type = 0}, then the residual variance is assumed to be constant
across all observations.}

\item{prior.sign}{A vector or list of vectors indicating the sign(s) of
the priors (-1 for nonpositive, 1 for nonnegative, and 0 otherwise). Only
used when initializing factors.}

\item{ebnm.fn}{A list of lists giving the functions to be used to solve the
Empirical Bayes normal means problem when updating each factor.}

\item{ebnm.param}{A list of lists giving the parameters to be passed to the
functions in \code{ebnm.fn}.}

\item{greedy.Kmax}{The maximum number of factors to be added. Fixed factors
are not counted.}

\item{backfit.order}{How to determine the order in which to backfit factors.
\code{"montaigne"} goes after the factor that promises to yield the
largest increase in the variational lower bound. Il faut courir au plus
press√©.}

\item{warmstart.backfits}{Whether to use the current prior parameters to
initialize the solution to the empirical Bayes normal means problem.}

\item{backfit.after}{A vector of factor indices. A backfit will be
performed each time one of these factors have been added.}

\item{backfit.every}{After the last factor in \code{backfit.after} is added,
an additional backfit will be performed after every \code{backfit.every}th
factor is added.}

\item{final.backfit}{Whether to perform a final backfit.}

\item{nullchk.after}{Similar to \code{backfit.after}, but for nullchecks.}

\item{nullchk.every}{Similar to \code{backfit.every}. For nullchecks.}

\item{final.nullchk}{Whether to perform a final nullcheck.}

\item{conv.crit.fn}{The function to use to determine whether convergence has
occurred. Used for both new factors and backfits.}

\item{verbose.lvl}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
Set to \code{-1} to output a single tab-delimited table of values.}

\item{verbose.fns}{A vector of functions. Used to calculate values to
output after each factor update.}

\item{verbose.colnames}{A vector of column names, one for each function in
\code{verbose.fns}.}

\item{verbose.colwidths}{A vector of column widths.}

\item{output.lvl}{What to include in the returned flash object. 0 = raw fit
only; 1 = trimmed fit, no sampler; 2 = raw fit and sampler; 3 = trimmed
fit and sampler.}

\item{EF.init}{A list of matrices, one for each dimension. Each matrix
should have k columns, one for each factor. New factors are initialized
at these values.}

\item{fix.dim}{A list of integers, one for each fixed factor. Specifies the
dimension along which the factor is (partially) fixed.}

\item{fix.idx}{A list of vectors, one for each fixed factor. Gives the
indices of the loadings to fix.}

\item{fix.vals}{A list of vectors that gives the values at which to fix
the loadings specified by \code{fix.idx}.}

\item{use.fixed.to.est.g}{Whether to include fixed values when estimating
priors on (partially) fixed factors.}

\item{nullchk.fixed.factors}{Whether to nullcheck fixed factors.}

\item{init.fn}{The function to use to initialize factors.}

\item{init.maxiter}{The maximum number of iterations when initializing
factors.}

\item{init.tol}{The maximum absolute change in normalized loadings that can
occur before initialization is considered complete.}

\item{greedy.maxiter}{The maximum number of iterations when optimizing a
new factor.}

\item{greedy.tol}{The convergence tolerance when optimizing a new factor.}

\item{backfit.maxiter}{The maximum number of iterations when performing a
final backfit.}

\item{backfit.tol}{The convergence tolerance when performing a final
backfit.}

\item{inner.backfit.maxiter}{Maximum iterations for intermediary backfits.}

\item{inner.backfit.tol}{Convergence tolerance for intermediary backfits.}

\item{seed}{By default, a seed is set for reproducibility. Set to
\code{NULL} for a random seed.}

\item{use.R}{Whether to maintain a matrix of residuals throughout the
fitting process. This usually requires much more memory and seldom offers
much improvement in runtime.}
}
\description{
Caveat emptor.
}
