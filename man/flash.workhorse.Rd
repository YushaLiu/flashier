% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_workhorse.R
\name{flash.workhorse}
\alias{flash.workhorse}
\title{A horse that works for \code{\link{flashier}}}
\usage{
flash.workhorse(data = NULL, init = NULL, var.type = 0,
  prior.sign = NULL, ebnm.fn = ebnm::ebnm, greedy.Kmax = 100,
  extrapolate.greedy = TRUE, backfit.kset = NULL,
  backfit.method = c("extrapolate", "sequential", "dropout", "montaigne",
  "random", "parallel"), warmstart.backfits = TRUE,
  backfit.after = NULL, backfit.every = NULL, final.backfit = FALSE,
  nullchk.after = NULL, nullchk.every = NULL, final.nullchk = TRUE,
  restart.after.nullchk = TRUE, conv.crit.fn = calc.obj.diff,
  verbose.lvl = 1, verbose.fns = NULL, verbose.colnames = NULL,
  verbose.colwidths = NULL, output.lvl = 3, EF.init = NULL,
  fix.dim = NULL, fix.idx = NULL, fix.vals = NULL,
  use.fixed.to.est.g = FALSE, nullchk.fixed.factors = FALSE,
  init.fn = NULL, init.maxiter = 100, init.tol = 0.01,
  maxiter = 500, tol = NULL, greedy.maxiter = maxiter,
  greedy.reltol = 1, fixed.maxiter = maxiter, fixed.reltol = 1,
  backfit.maxiter = maxiter, backfit.reltol = 1,
  inner.backfit.maxiter = backfit.maxiter,
  inner.backfit.reltol = backfit.reltol, nullchk.reltol = 1,
  extrapolate.control = list(), nonmissing.thresh = NULL, seed = 666,
  use.R = FALSE)
}
\arguments{
\item{data}{The observations. Can be a matrix, sparse matrix of class
\code{Matrix}, three-dimensional array, or \code{flash.data} object
obtained from \code{\link{set.flash.data}}. Can also be a low-rank matrix
representation as returned by, for example, \code{\link{svd}},
\code{\link[irlba]{irlba}}, \code{\link[rsvd]{rsvd}}, or
\code{\link[softImpute]{softImpute}}. Can be \code{NULL} if
\code{init} is used.}

\item{init}{An initial \code{flash} or \code{flash.fit} object.}

\item{var.type}{Describes the structure of the estimated residual variance.
Can be \code{NULL}, \code{0}, or a vector. If \code{NULL}, then
\code{S} accounts for all residual variance. Otherwise, a rank-one
variance structure will be estimated (and added to any variance specified
by \code{S}). \code{var.type} then gives the modes along which the
residual variance is permitted to vary. For example, \code{var.type = 1}
estimates row-specific residual variances, while \code{var.type = c(1, 2)}
optimizes over all rank-one matrices. If \code{var.type = 0}, then the
residual variance is assumed to be constant across all observations.}

\item{prior.sign}{A vector or list of vectors indicating the sign(s) of
the priors (-1 for nonpositive, 1 for nonnegative, and 0 otherwise). Only
used when initializing factors.}

\item{ebnm.fn}{A list of lists giving the functions to be used to solve the
Empirical Bayes normal means problem when updating each factor.}

\item{greedy.Kmax}{The maximum number of factors to be added. This will not
necessarily be the total number of factors added by \code{flashier}, since
factors are only added as long as they increase the variational lower
bound on the log likelihood for the model. Fixed factors are not counted
towards this limit.}

\item{extrapolate.greedy}{Whether to use an extrapolation technique
inspired by Ang and Gillis (2019) to accelerate the fitting of greedy
and fixed factors.}

\item{backfit.kset}{Which factors to backfit. The - operator can be used to
instead specify which factors not to backfit. For example,
\code{backfit.kset = -(1:2)} will backfit all factors but the first two.}

\item{backfit.method}{\code{"sequential"} updates each factor in order, one
at a time. \code{"extrapolate"} does the same but uses an acceleration
technique inspired by Ang and Gillis (2019). The extrapolation parameters
can be set via \code{extrapolate.control}. \code{"dropout"} is similar to
\code{"sequential"}, but stops updating individual factors once they are
no longer changing very much. \code{"montaigne"} goes after the factor that
promises to yield the largest increase in the variational lower bound.
Il faut courir au plus press√©. \code{"random"} updates each factor one at
a time, but re-orders them randomly after each backfit iteration.
\code{"parallel"} does a simultaneous update of all factors. Unlike other
methods, parallel backfits are not guaranteed to yield monotonic increases
in the variational lower bound.
The number of cores used by \code{"parallel"} can be set via the
command \code{options("cl.cores", n.cores)}. The type of multicore
cluster can be set via \code{options("cl.type", type)}. Typically,
\code{cl.type = "FORK"} is more efficient on Unix-likes.}

\item{warmstart.backfits}{Whether to use the current prior parameters to
initialize the solution to the empirical Bayes normal means problem.}

\item{backfit.after}{A vector of factor indices. A backfit will be
performed each time one of these factors have been added.}

\item{backfit.every}{After the last factor in \code{backfit.after} is added,
an additional backfit will be performed after every \code{backfit.every}th
factor is added.}

\item{final.backfit}{Whether to perform a final backfit.}

\item{nullchk.after}{Similar to \code{backfit.after}, but for nullchecks.}

\item{nullchk.every}{Similar to \code{backfit.every}. For nullchecks.}

\item{final.nullchk}{Whether to perform a final nullcheck.}

\item{restart.after.nullchk}{Whether to continue fitting if the final
nullcheck fails.}

\item{conv.crit.fn}{The function to use to determine whether convergence has
occurred. Used for both new factors and backfits.}

\item{verbose.lvl}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
Set to \code{-1} to output a single tab-delimited table of values.}

\item{verbose.fns}{A vector of functions. Used to calculate values to
output after each factor update.}

\item{verbose.colnames}{A vector of column names, one for each function in
\code{verbose.fns}.}

\item{verbose.colwidths}{A vector of column widths.}

\item{output.lvl}{What to include in the returned flash object. 0 = raw fit
only; 1 = trimmed fit, no sampler; 2 trimmed fit and sampler; 3 = raw fit
and sampler; 4 = raw fit, sampler, and lfsr (currently in beta).}

\item{EF.init}{A list of matrices, one for each dimension. Each matrix
should have k columns, one for each factor. New factors are initialized
at these values.}

\item{fix.dim}{A list of integers, one for each fixed factor. Specifies the
dimension along which the factor is (partially) fixed.}

\item{fix.idx}{A list of vectors, one for each fixed factor. Gives the
indices of the loadings to fix.}

\item{fix.vals}{A list of vectors that gives the values at which to fix
the loadings specified by \code{fix.idx}.}

\item{use.fixed.to.est.g}{Whether to include fixed values when estimating
priors on (partially) fixed factors.}

\item{nullchk.fixed.factors}{Whether to nullcheck fixed factors.}

\item{init.fn}{The function to use to initialize factors.}

\item{init.maxiter}{The maximum number of iterations when initializing
factors.}

\item{init.tol}{The maximum absolute change in normalized loadings that can
occur before initialization is considered complete.}

\item{maxiter}{The maximum number of iterations when adding a factor or
backfitting. To set different maximums for each type of fit, use
parameters \code{greedy.maxiter}, \code{fixed.maxiter},
\code{backfit.maxiter}, and \code{inner.backfit.maxiter}.}

\item{tol}{The convergence tolerance. Different tolerances can be used for
each type of fit by setting relative tolerances via parameters
\code{greedy.reltol}, \code{fixed.reltol}, \code{backfit.reltol},
and \code{inner.backfit.reltol}.}

\item{greedy.maxiter}{The maximum number of iterations when optimizing a
greedily added factor.}

\item{greedy.reltol}{The convergence tolerance (relative to tol) when
optimizing a greedily added factor.}

\item{fixed.maxiter}{The maximum number of iterations when optimizing a
newly added fixed factor.}

\item{fixed.reltol}{The convergence tolerance (relative to tol) when
optimizing a newly added fixed factor.}

\item{backfit.maxiter}{Maximum iterations for final backfits.}

\item{backfit.reltol}{Convergence tolerance for final backfits, relative to
tol.}

\item{inner.backfit.maxiter}{Maximum iterations for intermediary backfits.}

\item{inner.backfit.reltol}{Convergence tolerance for intermediary backfits,
relative to tol.}

\item{nullchk.reltol}{Tolerance for nullchecks, relative to tol.}

\item{extrapolate.control}{Extrapolation parameters. TODO: describe.}

\item{nonmissing.thresh}{A vector of thresholds, one for each mode. Each
threshold sets the (weighted) proportion of data that must be
nonmissing in a given matrix or array slice in order to estimate the
corresponding factor loading.}

\item{seed}{By default, a seed is set for reproducibility. Set to
\code{NULL} for a random seed.}

\item{use.R}{Whether to maintain a matrix of residuals throughout the
fitting process. This usually requires much more memory and seldom offers
much improvement in runtime.}
}
\description{
Caveat emptor.
}
